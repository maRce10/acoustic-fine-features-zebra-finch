---
title: Measuring schroeder periods
subtitle: Fine scale acoustic perception in zebra finches
author: Marcelo Araya-Salas
date: "`r Sys.Date()`"
toc: true
toc-depth: 2
toc-location: left
number-sections: true
highlight-style: pygments
format:
  html:
    df-print: kable
    code-fold: true
    code-tools: true
    css: qmd.css
editor_options: 
  chunk_output_type: console
---

```{r add link to github repo, echo = FALSE, results='asis'}

# print link to github repo if any
if (file.exists("../.git/config")) {
  config <- readLines("../.git/config")
  url <- grep("url", config, value = TRUE)
  url <- gsub("\\turl = |.git$", "", url)
  cat("\nSource code and data found at [", url, "](", url, ")", sep = "")
}

```

<!-- this code add line numbers to code blocks -->
<!-- only works when code folding is not used in yaml (code_folding: show) -->

<style>
body
  { counter-reset: source-line 0; }
pre.numberSource code
  { counter-reset: none; }
</style>

```{r load packages and setup style, echo = FALSE, message = FALSE, warning=FALSE}

# github packages must include user name ("user/package")
pkgs <- c("kableExtra", "knitr", "formatR", "seewave", "tuneR", "warbleR", "viridis", "Rraven", github = "maRce10/baRulho", "ggplot2", github = "PhenotypeSpace", "ecodist", "numform", "animation")

# install/ load packages
sketchy::load_packages(pkgs, quite = TRUE)

# options to customize chunk outputs
knitr::opts_chunk$set(
  class.source = "numberLines lineAnchors", # for code line numbers
  tidy.opts = list(width.cutoff = 65),
  tidy = TRUE,
  message = FALSE
)

knitr::opts_knit$set(root.dir = "..")
```

&nbsp; 

<!-- skyblue box -->

<div class="alert alert-info">

# Purpose

- Detect start and end of periods in a schroeder using amplitude cross-correlation
- Compare methods for measuring fine scale structural variation and periodicity in schroeders

</div>

&nbsp;

<!-- light brown box -->
<div class="alert alert-warning">

# Report overview

  - [Synthetizing schroeders](#synthetizing-schroeders)
  - [Detecting periodicity](#amplitude-cross-correlation)
  - [Measuring schroeder dissimilarity](#measuring-schroeder-dissimilarity)
  - [Takeaways](#takeaways)

</div>

&nbsp;
```{r}

source("~/Dropbox/Projects/geographic_call_variation_yellow-naped_amazon/scripts/MRM2.R")

warbleR_options(parallel = 22)

wave_col <- viridis(10)[7]

```


# Synthetizing schroeders

## Function to make schroeders

```{r}

qwindpc <- function(rftime, srate, sig) {
  ramppts <- round((rftime / 1000) * srate)
  hold1 <- seq(0, 1, length.out = ramppts + 1)
  onramp <- sin(0.5 * pi * hold1)^2
  offramp <- cos(0.5 * pi * hold1)^2
  steady <- rep(1, length(sig) - (2 * ramppts) - 2)
  wind <- c(onramp, steady, offramp)

  if (length(wind) > length(sig)) {
    print("Window not applied, block too short for window")
  } else {
    sig <- wind * sig
  }

  return(sig)
}


make_schroeder <-
  function(samp.rate = 44100,
           f0,
           dur = 1000,
           save.wave = FALSE,
           plot = TRUE,
           n.components,
           scalar = 1,
           color = wave_col,
           path = ".",
           file.name = NULL,
           random.start = FALSE,
           mfrow =  c(2, 1),
           par = TRUE,
           cex.oscillo = 1,
           ...) {
    
      # duplicate duration if starting randomly
    dur.mult <- if (random.start)  2 else 1
    
    # set time instances at which samples will be "taken"
    t <- seq(1 / samp.rate, 1, by = 1 / samp.rate)
    sumwavepos <- rep(0, samp.rate)

    durpts <- round((dur * dur.mult / 1000) * samp.rate)
 
    phase <- rep(0, n.components)
    amplin <- rep(1, n.components)
    f <- rep(0, n.components)

    Ns <- 1:n.components

    for (n in Ns) {
      compnum <- n
      phase[compnum] <- scalar * pi * compnum * (compnum - 1) / n.components
      f[n] <- f0 + ((compnum - 1) * f0)
    }

    wave <- matrix(0, nrow = n.components, ncol = length(t))

    for (i in Ns) {
      wave[i, ] <- amplin[i] * cos((2 * pi * f[i] * t) + phase[i])
      sumwavepos <- sumwavepos + wave[i, ]
    }

    # make sumwapos longer so it fit the target duration    
    org.sumwavepos <- sumwavepos
        
    while(length(sumwavepos) < durpts) 
        sumwavepos <- c(sumwavepos, org.sumwavepos) 

    posschr <- sumwavepos[1:durpts] / max(abs(sumwavepos[1:durpts]))

    # plot(t[1:length(posschr)], posschr, type = "l")

    spectr <- fft(sumwavepos)
    power <- abs(spectr)^2
    sample <- length(t) / max(t)
    freq <- (1:length(t)) * sample / length(t)
    powerdb <- 10 * log10(power[1:(length(t) / 2)])

    if (random.start){
        strt <- sample(1:(length(posschr) / 2), 1)
        posschr <- posschr[strt:(strt + (length(posschr) / 2) - 1)]
    }
    
     posschr <- qwindpc(10, samp.rate, posschr)
    posschr <- posschr / max(abs(posschr))
    
    wave_obj <- tuneR::normalize(tuneR::Wave(posschr, samp.rate = samp.rate, bit = 16), unit = "16")

    if (plot) {
      opar <- par()
      opar$cin <- opar$cra <- opar$sci <- opar$cxy <- opar$din <- opar$csi <- opar$page <- NULL

      # on.exit(par(opar))
      if (par)
      par(mfrow = mfrow, mar = c(5, 4, 0, 0) + 0.1)
      
      plot(
        freq[1:(length(t) / 2)],
        powerdb,
        type = "l",
        xlim = c(0, 5200),
        xlab = "Frequency (Hz)",
        ylab = "Power(dB)",
        col =  color,
        ... 
      )

      seewave::oscillo(wave = wave_obj, colwave = color, cexlab = cex.oscillo, cexaxis = cex.oscillo)
    }

    # Save audio to a file
    if (save.wave) {
      if (is.null(file.name)) {
        file.name <- paste0("f0-", f0, "_ncomp-", n.components, "_", if (scalar == 1) "pos" else "neg", ".wav")
      }
    writeWave(object = wave_obj, filename = file.path(path, file.name), extensible = FALSE)
    
    } else {
      return(wave_obj)
    }
  }
```


### Schroeder at 700 Hz with 7 components (harmonics) 

Positive
```{r}

ms <- make_schroeder(
  n.components = 7,
  samp.rate = 44100,
  f0 = 400,
  dur = 25,
  save.wave = FALSE,
  plot = TRUE,
  scalar = 1,
  color = viridis(10)[3], random.start = FALSE
)

```

Negative
```{r}

ms <- make_schroeder(
  n.components = 7,
  samp.rate = 44100,
  f0 = 400,
  dur = 25,
  save.wave = FALSE,
  plot = TRUE,
  scalar = -1,
  color = viridis(10)[3]
)

```

### Schroeder with 10 components

Positive
```{r}

ms <- make_schroeder(
  n.components = 10,
  samp.rate = 44100,
  f0 = 400,
  dur = 25,
  save.wave = FALSE,
  plot = TRUE,
  scalar = 1,
  color = viridis(10)[3]
)

```

Negative
```{r}

ms <- make_schroeder(
  n.components = 10,
  samp.rate = 44100,
  f0 = 400,
  dur = 25,
  save.wave = FALSE,
  plot = TRUE,
  scalar = -1,
  color = viridis(10)[3]
)

```

Randomly starting at any point
```{r}

ms <- make_schroeder(
  n.components = 10,
  samp.rate = 44100,
  f0 = 400,
  dur = 25,
  save.wave = FALSE,
  plot = TRUE,
  scalar = -1,
  color = viridis(10)[3], 
  random.start = TRUE
)

```

Make example video (or gif):

```{r, eval= FALSE}

ani.options(ani.res = 200, ani.width = 1700, ani.height = 1000, ani.type = "png")

## make sure ImageMagick has been installed in your system
# gifs <- function(lng_dat, type = "gif"){ 
  
  # anni_fun <- if(type == "gif") saveGIF else saveVideo
  
  
  saveGIF(expr = {

  for(i in 1:13){
  par(mfcol = c(2, 2), mar = c(5, 5, 3, 2) + 0.1)

ms <- make_schroeder(
  n.components = i,
  samp.rate = 44100,
  f0 = 400,
  dur = 25,
  save.wave = FALSE,
  plot = TRUE,
  scalar = 1,
  color = viridis(10)[3], random.start = FALSE,
  par = FALSE, 
  main = paste0("Positive, ", i, " components"),
  cex.main = 2, cex.lab = 2, cex.oscillo = 2
)

ms <- make_schroeder(
  n.components = i,
  samp.rate = 44100,
  f0 = 400,
  dur = 25,
  save.wave = FALSE,
  plot = TRUE,
  scalar = -1,
  color = viridis(10)[8], random.start = FALSE,
  par = FALSE,
  main = paste0("Negative, ", i, " components"),
    cex.main = 2, cex.lab = 2, cex.oscillo = 2
)

  }

  
}, video.name = file.path("./output/movies", "schroeders_by_sign_and_harmonics2"), interval = 1)
# }, movie.name = paste0(z,  ".", type), interval = 0.05)
# }

```

![schroeders_by_sign_and_harmonics](schroeders_by_sign_and_harmonics.gif){width=700}

## Make schroeders

Full factorial design of the following features:

 - Components: from 1 to 25 (21 values)
 - Fundamental frequency: from 200 to 800 (7 values)
 - Sign: 1 and -1
 - 294 schroeders
 
Create schroeders as individual sound files: 

- Fixed start
```{r, eval = FALSE}

shr_tab <- expand.grid(type = c(-1, 1), components = seq(5, 25, 1), f0 = seq(200, 800, 100))

nrow(shr_tab)


shr_tab$name <- paste0(f_pad_zero(x = 1:nrow(shr_tab), width = 3), "_f0-", shr_tab$f0, "_ncomp-", shr_tab$components, "_", ifelse(shr_tab$type == 1, "pos", "neg"), ".wav")

out <- warbleR:::pblapply_wrblr_int(seq_len(nrow(shr_tab)), function(x) {
  make_schroeder(
    n.components = shr_tab$components[x],
    samp.rate = 44100,
    f0 = shr_tab$f0[x],
    dur = 1000,
    save.wave = TRUE,
    plot = FALSE,
    scalar = shr_tab$type[x],
    color = "red",
    path = "./data/processed/schroeders",
    file.name = shr_tab$name[x]
  )
})

```

- Random start
```{r, eval = FALSE}

shr_tab <- expand.grid(type = c(-1, 1), components = seq(5, 25, 1), f0 = seq(200, 800, 100))

nrow(shr_tab)


shr_tab$name <- paste0(f_pad_zero(x = 1:nrow(shr_tab), width = 3), "_f0-", shr_tab$f0, "_ncomp-", shr_tab$components, "_", ifelse(shr_tab$type == 1, "pos", "neg"), ".wav")

out <- warbleR:::pblapply_wrblr_int(seq_len(nrow(shr_tab)), function(x) {
  make_schroeder(
    n.components = shr_tab$components[x],
    samp.rate = 44100,
    f0 = shr_tab$f0[x],
    dur = 1000,
    save.wave = TRUE,
    plot = FALSE,
    scalar = shr_tab$type[x],
    color = "red",
    path = "./data/processed/random_start_schroeders",
    file.name = shr_tab$name[x],
    random.start = TRUE    
  )
})

```


Put Schroeders into a single sound file

```{r, eval = FALSE}

# fix start
est_schr <- warbleR::selection_table(whole.recs = TRUE, path = "./data/processed/schroeders", extended = TRUE, confirm.extended = FALSE)

est_schr$bottom.freq <- (as.numeric(gsub("f0-", "", (sapply(strsplit(est_schr$sound.files, split = "_"), "[[", 2)))) - 50) / 1000

est_schr$top.freq <- freq_range(X = est_schr, threshold = 2, fsmooth = 0.8, parallel = 13)$top.freq

est_schr$f0 <- gsub("f0-", "", sapply(strsplit(est_schr$sound.files, split = "_"), "[[", 2))

est_schr$label <- gsub("os.wav_1|eg.wav_1", "", sapply(strsplit(est_schr$sound.files, split = "ncomp-"), "[[", 2))

saveRDS(est_schr, "./data/processed/extended_selection_table_schroeders.RDS")

master <- master_sound_file(X = est_schr, file.name = "schroeder_master", dest.path = "./data/processed/", gap.duration = 0.8, cex = 14)

write.csv(master, "./data/processed/master_annotations_schroeders.csv", row.names = FALSE)

master$f0 <- c("start_marker", paste("f0", est_schr$f0), "")


master$label <- c("marker", est_schr$label, "marker")

Rraven::exp_raven(master, path = "./data/processed/", sound.file.path = "./data/processed/")

warbleR::full_spectrograms(master, path = "./data/processed/", sxrow = duration(readWave("./data/processed/schroeder_master.wav")) / 12, rows = 12, horizontal = TRUE, dest.path = "./data/processed/spectrograms", collevels = seq(-150, 0, 5), labels = "label", song = "f0", wl = 2000)


# random start
est_schr <- warbleR::selection_table(whole.recs = TRUE, path = "./data/processed/random_start_schroeders", extended = TRUE, confirm.extended = FALSE)

est_schr$bottom.freq <- (as.numeric(gsub("f0-", "", (sapply(strsplit(est_schr$sound.files, split = "_"), "[[", 2)))) - 50) / 1000

est_schr$top.freq <- freq_range(X = est_schr, threshold = 2, fsmooth = 0.8, parallel = 13)$top.freq

est_schr$f0 <- gsub("f0-", "", sapply(strsplit(est_schr$sound.files, split = "_"), "[[", 2))

est_schr$label <- gsub("os.wav_1|eg.wav_1", "", sapply(strsplit(est_schr$sound.files, split = "ncomp-"), "[[", 2))

saveRDS(est_schr, "./data/processed/extended_selection_table_random_start_schroeders.RDS")

master <- master_sound_file(X = est_schr, file.name = "random_start_schroeder_master", dest.path = "./data/processed/", gap.duration = 0.8, cex = 14)

write.csv(master, "./data/processed/master_annotations_random_start_schroeders.csv", row.names = FALSE)

master$f0 <- c("start_marker", paste("f0", est_schr$f0), "")


master$label <- c("marker", est_schr$label, "marker")

Rraven::exp_raven(master, file.name = "random_start_schroeders", path = "./data/processed/", sound.file.path = "./data/processed/")

```

![master sound file](./schroeder_master--p1.jpeg){fig-align="center" width=100%}


# Detecting periodicity

- Create a function that returns each detected segment in a list
- Two methods: 
    - Empirical Mode Decomposition (EMD)
    - Time Autocorrelation (ac)
- The function can plot the mean period +/- standard deviation    
```{r}

est_schr <- readRDS("./data/processed/extended_selection_table_schroeders.RDS")

source("~/Dropbox/Projects/acoustic_fine_features_zebra_finch/scripts/mean_segment.R")

```

## Test function

mean period +/- standard deviation using autocorrelation
```{r}

est_schr <- readRDS("./data/processed/extended_selection_table_random_start_schroeders.RDS")

wave <- read_wave(est_schr, index = 40)

ms <-
  mean_segment(
    wave,
    thinning = 1,
    col = wave_col,
    mean = FALSE,
    plot = TRUE
  )

```

## Get mean schroeder cycles 

### EMD method
```{r, eval = FALSE}

est_schr <- readRDS("./data/processed/extended_selection_table_random_start_schroeders.RDS")

mean_schroeders <- warbleR:::pblapply_wrblr_int(cl = 20, seq_len(nrow(est_schr)), function(x) {
  wave <- read_wave(est_schr, index = x)
  seg <- try_na(mean_segment(wave, plot = FALSE, mean = FALSE, type = "EMD"))

  return(seg)
})

names(mean_schroeders) <- paste(est_schr$f0, est_schr$label, sep = "-")

saveRDS(mean_schroeders, "./data/processed/mean_random_start_schroeders_emd.RDS")
```

```{r, out.width="100%", warning=FALSE}

mean_schroeders <- readRDS("./data/processed/mean_random_start_schroeders_emd.RDS")

mean_schroeders <- mean_schroeders[!sapply(mean_schroeders, function(x) is.na(x[[1]][1]))]

mean_schroeders_list <- lapply(seq_len(length(mean_schroeders)), function(x) {
  data.frame(
    schroeder = names(mean_schroeders)[x],
    time = seq(0, 1, length.out = nrow(mean_schroeders[[x]])),
    mean.amp = rowMeans(mean_schroeders[[x]]),
    sd.amp = apply(mean_schroeders[[x]], 1, sd)
  )
})

mean_schroeders_df <- do.call(rbind, mean_schroeders_list)

ggplot(data = mean_schroeders_df[mean_schroeders_df$schroeder %in% unique(mean_schroeders_df$schroeder)[1:40], ], mapping = aes(x = time, y = mean.amp)) +
  geom_line(color = wave_col) +
  geom_ribbon(aes(ymin = mean.amp - sd.amp, ymax = mean.amp + sd.amp),
    alpha = 0.2
  ) +
  theme_classic(base_size = 5) +
  facet_wrap("~ schroeder", ncol = 5, scales = "free_y")
```

### Autocorrelation method

```{r, eval = FALSE}

est_schr <- readRDS("./data/processed/extended_selection_table_random_start_schroeders.RDS")

mean_schroeders <- warbleR:::pblapply_wrblr_int(cl = 20, seq_len(nrow(est_schr)), function(x) {
  wave <- read_wave(est_schr, index = x)
  seg <- try_na(mean_segment(wave, plot = FALSE, mean = FALSE, type = "ac", thinning = 0.8))

  return(seg)
})

names(mean_schroeders) <- paste(est_schr$f0, est_schr$label, sep = "-")

saveRDS(mean_schroeders, "./data/processed/mean_random_start_schroeders_ac.RDS")
```

```{r, out.width="100%", warning=FALSE}

mean_schroeders <- readRDS("./data/processed/mean_random_start_schroeders_ac.RDS")

mean_schroeders <- mean_schroeders[!sapply(mean_schroeders, function(x) is.na(x[[1]][1]))]

mean_schroeders_list <- lapply(seq_len(length(mean_schroeders)), function(x) {
  data.frame(
    schroeder = names(mean_schroeders)[x],
    time = seq(0, 1, length.out = nrow(mean_schroeders[[x]])),
    mean.amp = rowMeans(mean_schroeders[[x]]),
    sd.amp = apply(mean_schroeders[[x]], 1, sd)
  )
})

mean_schroeders_df <- do.call(rbind, mean_schroeders_list)

ggplot(data = mean_schroeders_df[mean_schroeders_df$schroeder %in% unique(mean_schroeders_df$schroeder)[1:40], ], mapping = aes(x = time, y = mean.amp)) +
  geom_line(color = wave_col) +
  geom_ribbon(aes(ymin = mean.amp - sd.amp, ymax = mean.amp + sd.amp),
    alpha = 0.2
  ) +
  theme_classic(base_size = 5) +
  facet_wrap("~ schroeder", ncol = 5, scales = "free_y")
```


# Measuring schroeder dissimilarity
## Dynamic-time warping pairwise distance

- Both Schroeders have the same length
- One is duplicated and the other one is slide across the duplicated one
- The minimum DTW distance is kept as a dissimilarity measure

```{r, eval = FALSE}

mean_schroeders <- readRDS("./data/processed/mean_random_start_schroeders_ac.RDS")

nms <- names(mean_schroeders)
# nms <- grep(pattern = "200|400|600|800", nms, value = TRUE)

cmbs <- t(combn(nms, 2))


min_dist_l <- pbapply::pbsapply(cl = 22, 1:nrow(cmbs), function(x) {
  s1 <- rowMeans(mean_schroeders[[cmbs[x, 1]]])
  s2 <- rowMeans(mean_schroeders[[cmbs[x, 2]]])

  # make same length
  # if (length(s1) != length(s2))
  s1 <- approx(s1, n = 100)$y
  s2 <- approx(s2, n = 100)$y

  # duplicate 1
  s1 <- rep(s1, 2)

  # run dtw over longer vector
  dists <- vapply(seq_len(length(s1) - length(s2)), function(x) {
    segment <- s1[x:min(c(x + length(s2) - 1), length(s1))]

    dtw_dist <- warbleR::try_na(dtw::dtwDist(mx = rbind(s2, segment)))
    return(dtw_dist[1, 2])
  }, FUN.VALUE = numeric(1))


  return(data.frame(schr1 = cmbs[x, 1], schdr2 = cmbs[x, 2], min(dists)))
})

min_dists <- do.call(rbind, min_dist_l)

min_dists <- as.data.frame(matrix(min_dists[, 1], ncol = 3, byrow = TRUE))

names(min_dists) <- c("schr1", "schr2", "dist")

min_dists$dist <- as.numeric(min_dists$dist)

saveRDS(min_dists, "./data/processed/dtw_distance_ac_segments_random_start.RDS")
```

# Compare dissimilarity between schroeders using different methods

We try 10 methods for measuring acoustic structure:

- [Dynamic time warping (DTW) distances from schroeder waveform](#waveform-dtw)
- [Raven's spectrographic features](#ravens-spectrographic-features)
- [warbleR's spectrographic features](#warblers-spectrographic-features)
- [warbleR's MFCC features](#warblers-mfcc-features)
- [warbleR's cross-correlation of fourier spectrograms](#warblers-fourier-cross-correlation)
- [Raven's cross-correlation of fourier spectrograms](#ravens-fourier-cross-correlation)
- [Raven's waveform correlation](#ravens-waveform-correlation)
- [warbleR's cross-correlation of mel-frequency spectrograms](#warblers-mel-frequency-cross-correlation)
- [DTW on warbleR's dominant frequency contours](#dtw-on-warblers-dominant-frequency-contours)
- [DTW on Raven's peak frequency contours](#dtw-on-ravens-peak-frequency-contours)

Statistical modeling:
 - [Multiple Regression on distance Matrices](https://search.r-project.org/CRAN/refmans/ecodist/html/MRM.html) 
 - Model:   
 \begin{align*}
 Dissimilarity &\sim frequency + components + sign
 \end{align*}
 - Response values scaled to make effect sizes comparable across models
 - Predictors were coded as pairwise binary matrices in which 0 means that calls in a dyad belong to the same level and 1 means calls belong to different levels 

## Waveform DTW
```{r, eval=FALSE}

min_dists <- readRDS("./data/processed/dtw_distance_ac_segments_random_start.RDS")

min_dists$dist <- scale(min_dists$dist)

dist_tri <- PhenotypeSpace::rectangular_to_triangular(min_dists)

freq_bi_tri <- as.dist(binary_triangular_matrix(group = sapply(strsplit(rownames(dist_tri), "-"), "[[", 1)))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = gsub("_n|_p", "", sapply(strsplit(rownames(dist_tri), "-"), "[[", 2))))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = sapply(strsplit(rownames(dist_tri), "_"), "[[", 2)))

rect_var <- cbind(as.dist(dist_tri), freq_bi_tri, comp_bi_tri, sign_bi_tri)

colnames(rect_var) <- c("dtw_dist", "frequency", "components", "sign")

dtw_wv_mod <- MRM2(formula = dtw_dist ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  dtw_wv_mod,
  "./data/processed/matrix_correlation_dtw_distance_random_start.RDS"
)
```

```{r}

(dtw_wv_mod <- readRDS("./data/processed/matrix_correlation_dtw_distance_random_start.RDS"))
```

## Raven's spectrographic features
```{r, eval = FALSE}

rav_dat <- imp_raven(path = "./data/processed", files = "random_start_schroeder_master_raven_measurements.txt", warbler.format = TRUE, all.data = TRUE)

rav_dat <- rav_dat[grep(pattern = "marker", rav_dat$f0, invert = TRUE), ]

rav_dat <- rav_dat[, grep("contour|PFC Slope", ignore.case = TRUE, x = names(rav_dat), invert = TRUE)]

pca <- prcomp(x = rav_dat[, names(rav_dat) %in% c("Agg Entropy (bits)", "Avg Entropy (bits)", "Avg Power Density (dB FS/Hz)", "BW 50% (Hz)", "BW 90% (Hz)", "Center Freq (Hz)", "Center Time Rel.", "Delta Freq (Hz)", "Dur 50% (s)", "Dur 90% (s)", "Energy (dB FS)", "Freq 25% (Hz)", "Freq 5% (Hz)", "Freq 75% (Hz)", "Freq 95% (Hz)", "Inband Power (dB FS)", "Max Entropy (bits)", "Max Freq (Hz)", "Min Entropy (bits)", "Peak Freq (Hz)", "PFC Avg Slope (Hz/ms)", "PFC Max Freq (Hz)", "PFC Max Slope (Hz/ms)", "PFC Min Freq (Hz)", "PFC Min Slope (Hz/ms)", "PFC Num Inf Pts", "Peak Power Density (dB FS/Hz)", "Peak Time (s)", "Peak Time Relative", "Time 25% (s)", "Time 25% Rel.", "Time 5% (s)", "Time 5% Rel.", "Time 75% (s)", "Time 75% Rel.", "Time 95% (s)", "Time 95% Rel.")], scale. = TRUE)

rav_dat$pc1 <- pca$x[, 1]
rav_dat$pc2 <- pca$x[, 2]
rav_dat$comp <- sapply(strsplit(rav_dat$label, "_"), "[[", 1)
rav_dat$sign <- sapply(strsplit(rav_dat$label, "_"), "[[", 2)
rav_dat$label <- paste(rav_dat$f0, rav_dat$label, sep = "-")

dist_tri <- dist(rav_dat[, c("pc1", "pc2")])

freq_bi_tri <- as.dist(binary_triangular_matrix(group = rav_dat$f0))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = rav_dat$comp))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = rav_dat$sign))

rect_var <- cbind(as.dist(scale(as.matrix(dist_tri))), freq_bi_tri, comp_bi_tri, sign_bi_tri)

colnames(rect_var) <- c("rav_dist", "frequency", "components", "sign")


rav_mod <- MRM2(formula = rav_dist ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  rav_mod,
  "./data/processed/matrix_correlation_raven_measurements_distance_random_start.RDS"
)
```

```{r}
(rav_mod <- readRDS("./data/processed/matrix_correlation_raven_measurements_distance_random_start.RDS"))
```

## warbleR's spectrographic features
```{r, eval = FALSE}

est_schr <- readRDS("./data/processed/extended_selection_table_random_start_schroeders.RDS")

wsp <- spectro_analysis(est_schr, harmonicity = TRUE, nharmonics = 5, parallel = 20)

# keep columns with no NAs
wsp <- wsp[complete.cases(wsp), ]

pca <- prcomp(x = wsp[, -c(1:3)])
wsp$pc1 <- pca$x[, 1]
wsp$pc2 <- pca$x[, 2]

wsp_tri <- dist(wsp[, c("pc1", "pc2")])

freq_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(wsp$sound.files, "_"), "[[", 2), start = 4, 6)))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(wsp$sound.files, "_"), "[[", 3), start = 7, 8)))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = ifelse(grepl("pos", wsp$sound.files), "pos", "neg")))

rect_var <- cbind(as.dist(scale(as.matrix(wsp_tri))), freq_bi_tri, comp_bi_tri, sign_bi_tri)

colnames(rect_var) <- c("wrbl_sp", "frequency", "components", "sign")

wrbl_mod <- MRM2(formula = wrbl_sp ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  wrbl_mod,
  "./data/processed/matrix_correlation_warbler_measurements_distance_random_start.RDS"
)
```

```{r}

(wrbl_mod <- readRDS("./data/processed/matrix_correlation_warbler_measurements_distance_random_start.RDS"))

```

## warbleR's MFCC features
```{r, eval = FALSE}

est_schr <- readRDS("./data/processed/extended_selection_table_random_start_schroeders.RDS")

wsp <- mfcc_stats(est_schr)

# keep columns with no NAs
wsp <- wsp[complete.cases(wsp), ]

pca <- prcomp(x = wsp[, -c(1:3)])
wsp$pc1 <- pca$x[, 1]
wsp$pc2 <- pca$x[, 2]

wsp_tri <- dist(wsp[, c("pc1", "pc2")])

freq_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(wsp$sound.files, "_"), "[[", 2), start = 4, 6)))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(wsp$sound.files, "_"), "[[", 3), start = 7, 8)))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = ifelse(grepl("pos", wsp$sound.files), "pos", "neg")))

rect_var <- cbind(as.dist(scale(as.matrix(wsp_tri))), freq_bi_tri, comp_bi_tri, sign_bi_tri)

colnames(rect_var) <- c("wrbl_sp", "frequency", "components", "sign")

mfcc_wrbl_mod <- MRM2(formula = wrbl_sp ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  mfcc_wrbl_mod,
  "./data/processed/mfcc_warbler_distance_random_start.RDS"
)
```

```{r}

(mfcc_wrbl_mod <- readRDS("./data/processed/mfcc_warbler_distance_random_start.RDS"))
```

## warbleR's fourier cross-correlation
```{r, eval = FALSE}

est_schr <- readRDS("./data/processed/extended_selection_table_random_start_schroeders.RDS")

xc <- cross_correlation(est_schr)

saveRDS(xc, "./data/processed/fourier_cross_correlation_random_start_schroeder.RDS")

```

```{r, eval = FALSE}

xc <- readRDS("./data/processed/fourier_cross_correlation_random_start_schroeder.RDS")

freq_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(xc), "_"), "[[", 2), start = 4, 6)))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(xc), "_"), "[[", 3), start = 7, 8)))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = ifelse(grepl("pos", rownames(xc)), "pos", "neg")))

rect_var <- cbind(as.dist(scale(1 - xc)), freq_bi_tri, comp_bi_tri, sign_bi_tri)

colnames(rect_var) <- c("fourier_xc", "frequency", "components", "sign")

xc_mod <- MRM2(formula = fourier_xc ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  xc_mod,
  "./data/processed/matrix_correlation_fourier_cross_correlation_random_start.RDS"
)
```

```{r}

(xc_mod <- readRDS("./data/processed/matrix_correlation_fourier_cross_correlation_random_start.RDS"))
```

## Raven's fourier cross-correlation
```{r, eval = FALSE}

xc_rav <- Rraven::imp_corr_mat(file = "random_start_schroeders_raven_fourier_cross_correlation.txt", path = "./data/processed")[[1]]

freq_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(xc_rav), "_"), "[[", 2), start = 4, 6)))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(xc_rav), "_"), "[[", 3), start = 7, 8)))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = ifelse(grepl("pos", rownames(xc_rav)), "pos", "neg")))

rect_var <- cbind(as.dist(scale(1 - xc_rav)), freq_bi_tri, comp_bi_tri, sign_bi_tri)

colnames(rect_var) <- c("fourier_xc_rav", "frequency", "components", "sign")

xc_rav_mod <- MRM2(formula = fourier_xc_rav ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  xc_rav_mod,
  "./data/processed/matrix_correlation_raven_fourier_cross_correlation_random_start.RDS"
)

```

```{r}

(xc_rav_mod <- readRDS("./data/processed/matrix_correlation_raven_fourier_cross_correlation_random_start.RDS"))

```

## Raven's waveform correlation
```{r, eval = FALSE}

wav_cr_rav <- Rraven::imp_corr_mat(file = "random_start_schroeders_raven_waveform_correlation.txt", path = "./data/processed")[[1]]

freq_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(wav_cr_rav), "_"), "[[", 2), start = 4, 6)))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(wav_cr_rav), "_"), "[[", 3), start = 7, 8)))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = ifelse(grepl("pos", rownames(wav_cr_rav)), "pos", "neg")))

rect_var <- cbind(as.dist(scale(1 - wav_cr_rav)), freq_bi_tri, comp_bi_tri, sign_bi_tri)

colnames(rect_var) <- c("fourier_wav_cr_rav", "frequency", "components", "sign")

wav_cr_rav_mod <- MRM2(formula = fourier_wav_cr_rav ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  wav_cr_rav_mod,
  "./data/processed/matrix_correlation_raven_waveform_correlation_random_start.RDS"
)

```

```{r}

(wav_cr_rav_mod <- readRDS("./data/processed/matrix_correlation_raven_waveform_correlation_random_start.RDS"))

```

## warbleR's mel-frequency cross-correlation
```{r, eval = FALSE}

est_schr <- readRDS("./data/processed/extended_selection_table_random_start_schroeders.RDS")

xc <- cross_correlation(est_schr, type = "mfcc")

saveRDS(xc, "./data/processed/mel_frequency_cross_correlation_schroeder_random_start.RDS")

```

```{r, eval=FALSE}

xc <- readRDS("./data/processed/mel_frequency_cross_correlation_schroeder_random_start.RDS")

freq_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(xc), "_"), "[[", 2), start = 4, 6)))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(xc), "_"), "[[", 3), start = 7, 8)))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = ifelse(grepl("pos", rownames(xc)), "pos", "neg")))

rect_var <- cbind(as.dist(scale(1 - xc)), freq_bi_tri, comp_bi_tri, sign_bi_tri)


colnames(rect_var) <- c("mel_xc", "frequency", "components", "sign")


mxc_mod <- MRM2(formula = mel_xc ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  mxc_mod,
  "./data/processed/matrix_correlation_mel_cross_correlation_random_start.RDS"
)
```

```{r}

(mxc_mod <- readRDS("./data/processed/matrix_correlation_mel_cross_correlation_random_start.RDS"))

```

## DTW on warbleR's dominant frequency contours
```{r, eval = FALSE}

source("~/Dropbox/R_package_testing/warbleR/R/freq_DTW.R")
source("~/Dropbox/R_package_testing/warbleR/R/internal_functions.R")

est_schr <- readRDS("./data/processed/extended_selection_table_random_start_schroeders.RDS")

dtw_dists <- freq_DTW(est_schr, type = "dominant", img = FALSE)

saveRDS(dtw_dists, "./data/processed/dtw_distance_dominant_frequency_schroeder_random_start.RDS")

```

```{r, eval=FALSE}

dtw_dists <- readRDS("./data/processed/dtw_distance_dominant_frequency_schroeder_random_start.RDS")

freq_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(dtw_dists), "_"), "[[", 2), start = 4, 6)))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(dtw_dists), "_"), "[[", 3), start = 7, 8)))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = ifelse(grepl("pos", rownames(dtw_dists)), "pos", "neg")))

rect_var <- cbind(as.dist(scale(dtw_dists)), freq_bi_tri, comp_bi_tri, sign_bi_tri)

colnames(rect_var) <- c("dtw_dists", "frequency", "components", "sign")

dtw_dom_mod <- MRM2(formula = dtw_dists ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  dtw_dom_mod,
  "./data/processed/matrix_correlation_dtw_distances_dominant_frequency_contours_random_start.RDS"
)
```

```{r}

(dtw_dom_mod <- readRDS("./data/processed/matrix_correlation_dtw_distances_dominant_frequency_contours_random_start.RDS"))

```

## DTW on Raven's peak frequency contours
```{r, eval = FALSE}

source("~/Dropbox/R_package_testing/warbleR/R/freq_DTW.R")
source("~/Dropbox/R_package_testing/warbleR/R/internal_functions.R")

rav_dat <- imp_raven(path = "./data/processed", files = "random_start_schroeder_master_raven_measurements.txt", warbler.format = TRUE, all.data = TRUE)

rav_dat <- rav_dat[grep(pattern = "marker", rav_dat$f0, invert = TRUE), ]

# rav_dat <- rav_dat[, grep("contour|PFC Slope", ignore.case = TRUE, x = names(rav_dat), invert = TRUE)]

rav_freq_cntr <- extract_ts(rav_dat, ts.column = "Peak Freq Contour (Hz)", equal.length = TRUE)


est_schr <- readRDS("./data/processed/extended_selection_table_random_start_schroeders.RDS")

rav_dtw_dists <- freq_DTW(est_schr, ts.df = rav_freq_cntr, type = "dominant", img = FALSE)

rownames(rav_dtw_dists) <- rav_dat$orig.sound.file

saveRDS(rav_dtw_dists, "./data/processed/dtw_distance_raven_dominant_frequency_random_start_schroeder.RDS")

```

```{r, eval=FALSE}

rav_dtw_dists <- readRDS("./data/processed/dtw_distance_raven_dominant_frequency_random_start_schroeder.RDS")

freq_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(rav_dtw_dists), "_"), "[[", 2), start = 4, 6)))

comp_bi_tri <- as.dist(binary_triangular_matrix(group = substr(sapply(strsplit(rownames(rav_dtw_dists), "_"), "[[", 3), start = 7, 8)))

sign_bi_tri <- as.dist(binary_triangular_matrix(group = ifelse(grepl("pos", rownames(rav_dtw_dists)), "pos", "neg")))

rect_var <- cbind(as.dist(scale(rav_dtw_dists)), freq_bi_tri, comp_bi_tri, sign_bi_tri)

colnames(rect_var) <- c("rav_dtw_dists", "frequency", "components", "sign")

source("~/Dropbox/Projects/geographic_call_variation_yellow-naped_amazon/scripts/MRM2.R")

dtw_rav_peak_mod <- MRM2(formula = rav_dtw_dists ~ frequency + components + sign, nperm = 10000, mat = rect_var)

saveRDS(
  dtw_rav_peak_mod,
  "./data/processed/matrix_correlation_dtw_distances_raven_dominant_frequency_contours_random_start.RDS"
)
```

```{r}

(dtw_rav_peak_mod <- readRDS("./data/processed/matrix_correlation_dtw_distances_raven_dominant_frequency_contours_random_start.RDS"))

```

## Combined results
```{r, fig.cap = "Effect sizes per model and predictor (color intensity shows effect size magnitude relative to the highest effect size within the model).", out.width="100%"}

mods <- list(dtw_wv_mod = dtw_wv_mod, wrbl_mod = wrbl_mod, mfcc_wrbl_mod = mfcc_wrbl_mod, rav_mod = rav_mod, xc_mod = xc_mod, mxc_mod = mxc_mod, dtw_dom_mod = dtw_dom_mod, dtw_rav_peak_mod = dtw_rav_peak_mod, wav_cr_rav_mod = wav_cr_rav_mod, xc_rav_mod = xc_rav_mod)

names(mods) <- c("DTW waveform period", "warbleR's spectro features", "warbleR's MFCC features",  "Raven's spectro features", "warbleR's Fourier cross-correlation", "Mel cross-correlation", "DTW warbleR's dominant freq", "DTW Raven's peak freq", "waveform correlation", "Raven's Fourier cross-correlation")

estimates <- do.call(rbind, lapply(seq_along(mods), function(x) {
  Y <- data.frame(mods[[x]]$coef[-1, ])
  Y$rel_coef <- Y[, 1] / max(Y[, 1])
  Y$mod <- names(mods)[x]
  Y$predictor <- rownames(Y)
  names(Y) <- c("coef", "p", "rel_coef", "model", "predictor")
  return(Y)
}))

estimates$rel_coef <- ifelse(estimates$p < 0.05, estimates$rel_coef, 0)
estimates$signif <- ifelse(estimates$p < 0.05, "p < 0.05", "p >= 0.05")

estimates$model <- factor(estimates$model, levels = rev(c("Raven's spectro features", "Raven's Fourier cross-correlation", "waveform correlation", "DTW Raven's peak freq", "warbleR's spectro features", "warbleR's MFCC features", "warbleR's Fourier cross-correlation", "Mel cross-correlation", "DTW warbleR's dominant freq",  "DTW waveform period" )))



ggplot(estimates, aes(x = predictor, y = model, fill = rel_coef)) +
  geom_tile() +
  coord_equal() + 
    scale_fill_gradient2(
low = viridis(10)[3], high = viridis(10)[7],
    guide = "none"
  ) +
  geom_text(aes(label = round(coef, 3), color = signif)) +
  scale_color_manual(values = c("black", "gray"))+
    labs(x = "", y = "", color = "P value") +
  theme_classic() +
  theme(axis.text.x = element_text(
    color = "black",
    size = 11, angle = 30, vjust = 0.8, hjust = 0.8
  ),
   axis.text.y = element_text(color =  c(rep(viridis(10)[4], 6), rep(viridis(10)[6], 4))))

```

<!-- light green box -->

<div class="alert alert-success">

&nbsp; 

# Takeaways

- Amplitude autocorrelation works better at getting periodicity 
- Dynamic time warping dissimilarity on mean periods, Raven's waveform correlation and (to some extent) Fourier cross-correlation did capture sign differences in Schroeders
- Dynamic time warping dissimilarity on mean periods remove differences in frequency when forcing all periods to have the same number of values (i.e. same length)

</div>

&nbsp;

<!-- '---' adds a gray vertical line -->

---


```{r, eval = FALSE, echo = FALSE}

sels <- imp_raven(path = "./data/raw", warbler.format = TRUE, all.data = TRUE)

cs <- check_sels(sels, path = "./data/raw/SchroederFiles_Try1/")


warbleR_options(wav.path = "./data/raw/SchroederFiles_Try1/")

cc <- cross_correlation(sels)

mdscc <- cmdscale(cc, 2)

sp <- spectro_analysis(sels)

mc <- mfcc_stats(sels)
```

&nbsp; 
 
 <!-- add packages used, system details and versions  -->
 
<font size="4">Session information</font>

```{r session info, echo=F}

sessionInfo()
```


